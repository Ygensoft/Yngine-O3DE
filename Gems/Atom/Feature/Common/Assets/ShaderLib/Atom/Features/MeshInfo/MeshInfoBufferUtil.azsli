/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */
#pragma once

#include <Atom/Features/Bindless.azsli>
#include <Atom/Features/MeshInfo/MeshInfo.azsli>
#include <Atom/RPI/VertexBufferOperations.azsli>
#include <Atom/RPI/IndexBufferOperations.azsli>

// Check if the size of the bindless buffer is big enough for the offset we try to read, since this can lead to GPU crashes 
// with vulkan, which are very hard to debug.
// disabled by default, since it has a performance overhead
#ifndef DEFENSIVE_BINDLESS_ACCESS
#define DEFENSIVE_BINDLESS_ACCESS 0
#endif

float2 LoadFromVertexBuffer_float2(const int bufferIndex, const uint bufferOffset, const uint bufferStride, const VertexFormat format, const uint index)
{    
    if (bufferIndex < 0)
    {
        return (float2)0;
    }
    ByteAddressBuffer buffer = Bindless::GetByteAddressBuffer(bufferIndex);
    const uint loadOffset = CalculateVertexLoadOffset(index, bufferOffset, bufferStride);
#if DEFENSIVE_BINDLESS_ACCESS
    uint bufferSize;
    buffer.GetDimensions(bufferSize);
    if (loadOffset + GetVertexFormatSize(format) >= bufferSize)
    {
        return (float2)0;
    }
#endif
    return LoadFloat2FromBuffer(buffer, loadOffset, format);

}

float3 LoadFromVertexBuffer_float3(const int bufferIndex, const uint bufferOffset, const uint bufferStride, const VertexFormat format, const uint index)
{
    if (bufferIndex < 0)
    {
        return (float3)0;
    }
    ByteAddressBuffer buffer = Bindless::GetByteAddressBuffer(bufferIndex);
    const uint loadOffset = CalculateVertexLoadOffset(index, bufferOffset, bufferStride);
#if DEFENSIVE_BINDLESS_ACCESS
    uint bufferSize;
    buffer.GetDimensions(bufferSize);
    if (loadOffset + GetVertexFormatSize(format) >= bufferSize)
    {
        return (float3)0;
    }
#endif
    return LoadFloat3FromBuffer(buffer, loadOffset, format);
}

float4 LoadFromVertexBuffer_float4(const int bufferIndex, const uint bufferOffset, const uint bufferStride, const VertexFormat format, const uint index)
{
    if (bufferIndex < 0)
    {
        return (float4)0;
    }
    ByteAddressBuffer buffer = Bindless::GetByteAddressBuffer(bufferIndex);
    const uint loadOffset = CalculateVertexLoadOffset(index, bufferOffset, bufferStride);
#if DEFENSIVE_BINDLESS_ACCESS
    uint bufferSize;
    buffer.GetDimensions(bufferSize);
    if (loadOffset + GetVertexFormatSize(format) >= bufferSize)
    {
        return (float4)0;
    }
#endif
    return LoadFloat4FromBuffer(buffer, loadOffset, format);
}

uint3 LoadFromIndexBuffer(const int bufferIndex, const uint bufferOffset, const uint bufferStride, const IndexFormat format, const uint index)
{
    if (bufferIndex < 0)
    {
        return (uint3)0;
    }
    ByteAddressBuffer buffer = Bindless::GetByteAddressBuffer(bufferIndex);
    const uint loadOffset = CalculateIndexLoadOffset(index * 3, bufferOffset, bufferStride);
#if DEFENSIVE_BINDLESS_ACCESS
    uint bufferSize;
    buffer.GetDimensions(bufferSize);
    if (loadOffset + GetIndexFormatSize(format) >= bufferSize)
    {
        return (uint3)0;
    }
#endif
    return LoadVertexIndices(buffer, loadOffset, format);
}

bool GetMeshInfoEntry(int index, inout MeshInfo meshInfo)
{
#if DEFENSIVE_BINDLESS_ACCESS
    uint numStructs;
    uint stride;
    SceneSrg::m_meshInfo.GetDimensions(numStructs, stride);
    if (index < 0 || index >= numStructs)
    {
        return false;
    }
#else
    if (index < 0) 
    {
        return false;
    }
#endif
    meshInfo = SceneSrg::m_meshInfo[index];
    return true;
}

uint3 LoadIndex(const MeshInfo meshInfo, uint triangleIndex)
{
    return LoadFromIndexBuffer(
        meshInfo.m_indexBufferIndex,
        meshInfo.m_indexBufferByteOffset,
        meshInfo.m_indexBufferByteStride,
        (IndexFormat)meshInfo.m_indexFormat,
        triangleIndex);
}

float3 LoadPosition(const MeshInfo meshInfo, uint vertexIndex)
{
    return LoadFromVertexBuffer_float3(
        meshInfo.m_positionBufferIndex,
        meshInfo.m_positionBufferByteOffset,
        meshInfo.m_positionBufferByteStride,
        (VertexFormat)meshInfo.m_positionFormat,
        vertexIndex);
}

float3 LoadNormal(const MeshInfo meshInfo, uint vertexIndex)
{
    return LoadFromVertexBuffer_float3(
        meshInfo.m_normalBufferIndex,
        meshInfo.m_normalBufferByteOffset,
        meshInfo.m_normalBufferByteStride,
        (VertexFormat)meshInfo.m_normalFormat,
        vertexIndex);
}

float2 LoadUv0(const MeshInfo meshInfo, uint vertexIndex)
{
    return LoadFromVertexBuffer_float2(
        meshInfo.m_uv0BufferIndex,
        meshInfo.m_uv0BufferByteOffset,
        meshInfo.m_uv0BufferByteStride,
        (VertexFormat)meshInfo.m_uv0Format,
        vertexIndex);
}

float2 LoadUv1(const MeshInfo meshInfo, uint vertexIndex)
{
    return LoadFromVertexBuffer_float2(
        meshInfo.m_uv1BufferIndex,
        meshInfo.m_uv1BufferByteOffset,
        meshInfo.m_uv1BufferByteStride,
        (VertexFormat)meshInfo.m_uv1Format,
        vertexIndex);
}

float4 LoadTangent(const MeshInfo meshInfo, uint vertexIndex)
{
    return LoadFromVertexBuffer_float4(
        meshInfo.m_tangentBufferIndex,
        meshInfo.m_tangentBufferByteOffset,
        meshInfo.m_tangentBufferByteStride,
        (VertexFormat)meshInfo.m_tangentFormat,
        vertexIndex);
}

float3 LoadBitangent(const MeshInfo meshInfo, uint vertexIndex)
{
    return LoadFromVertexBuffer_float3(
        meshInfo.m_bitangentBufferIndex,
        meshInfo.m_bitangentBufferByteOffset,
        meshInfo.m_bitangentBufferByteStride,
        (VertexFormat)meshInfo.m_bitangentFormat,
        vertexIndex);
}

void LoadTriangleVertices(const MeshInfo meshInfo, const uint triangleId, inout float3 p0, inout float3 p1, inout float3 p2)
{
    uint3 triangleIndices = LoadIndex(meshInfo, triangleId);
    p0 = LoadPosition(meshInfo, triangleIndices[0]);
    p1 = LoadPosition(meshInfo, triangleIndices[1]);
    p2 = LoadPosition(meshInfo, triangleIndices[2]);
}
