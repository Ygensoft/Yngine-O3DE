/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */
#pragma once

#include <Atom/Features/FallbackPBRMaterial/FallbackPBRMaterial_Defines.azsli>
#include <Atom/Features/FallbackPBRMaterial/FallbackPBRMaterial.azsli>

#include <Atom/Features/MeshInfo/MeshInfoUtil.azsli>
#include <Atom/Features/FallbackPBRMaterial/MaterialInfoUtil.azsli>
#include <Atom/Features/MatrixUtility.azsli>


Surface GetFallbackPBRStandardSurface(int meshInfoIndex, int triangleId, float3 barycentrics, sampler linearSampler, const float mipLevel = 0)
{
    Surface surface = (Surface)0;

    MeshInfo meshInfo;
    if (!GetMeshInfoEntry(meshInfoIndex, meshInfo))
    {
        return surface;
    }

    VsInput objectVertex;
    LoadInterpolatedVertexData(meshInfo, triangleId, barycentrics, objectVertex);
    
    // The EvaluateVertexGeometry() - function uses the viewProjectionMatrix to fill the 
    // vertex.position. We are fine without that though, since the geoData and Surface only use the positionWS,
    // and the vertex never leaves this function
    float4x4 viewProjectionMatrix = CreateIdentity4x4();
    VsOutput vertex = EvaluateVertexGeometry(objectVertex, meshInfo.m_objectIdForTransform, viewProjectionMatrix);
    PixelGeometryData geoData = EvaluatePixelGeometry(vertex, meshInfo.m_objectIdForTransform);

    MaterialInfo materialInfo;
    if (!GetMaterialInfoEntry(meshInfoIndex, materialInfo))
    {
        return surface;
    }
    TextureData textureData = GetFallbackPBRMaterialTextureData(materialInfo, linearSampler, geoData.uvs[0], mipLevel);
    surface = EvaluateSurface(geoData, textureData, materialInfo.m_irradianceColor, meshInfo.m_lightingChannels);
    return surface;
}
