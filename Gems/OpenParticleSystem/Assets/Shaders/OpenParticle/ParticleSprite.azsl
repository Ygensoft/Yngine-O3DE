#pragma once

#include <viewsrg_all.srgi>
#include <scenesrg_all.srgi>

#define PIPELINE_HAS_PASS_SRG 0

#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>
#include <Atom/Features/PBR/DefaultObjectSrg.azsli>
#include <OpenParticle/ParticleCommon.azsli>
#include <OpenParticle/ParticleAlphaUtils.azsli>
#include <OpenParticle/ParticleEmissiveInput.azsli>
#include <Atom/Features/Pipeline/Forward/ForwardPassVertexData.azsli>
#include <Atom/Features/Pipeline/Forward/ForwardPassPipelineCallbacks.azsli>

option enum class FacingMode {CameraPos, CameraSquare, CameraRectangle, Velocity, Custom } o_facingMode;

ShaderResourceGroup MaterialSrg : SRG_PerMaterial
{
    Texture2D m_baseColorMap;
    float m_alphaCutoff;

    float3      m_emissiveColor;
    float       m_emissiveIntensity;
    Texture2D   m_emissiveMap;
    uint        m_emissiveMapUvIndex;

    Sampler m_sampler
    {
        MaxAnisotropy = 16;
        AddressU = Wrap;
        AddressV = Wrap;
        AddressW = Wrap;
    };
}

static float4 positions[4] = {
        float4(-1.0, 0.0, -1.0, 0.0),
        float4( 1.0, 0.0, -1.0, 0.0),
        float4(-1.0, 0.0,  1.0, 0.0),
        float4( 1.0, 0.0,  1.0, 0.0)
};

static float2 uvs[4] = {
    float2(0, 0),
    float2(1, 0),
    float2(0, 1),
    float2(1, 1)
};

struct VertexInput
{
    float4 position : POSITION;
    float4 color    : COLOR;
    float4 initRotation : INITROTATION;
    float4 rotateVector : ROTATEVECTOR;
    float4 scale    : SCALE;
    float4 up       : UP;
    float4 velocity : VELOCITY;
    float4 subuv    : SUBUV;
    uint vertexId : SV_VertexID;
};

struct VertexOutput
{
    float4 position : SV_Position;
    float4 color : COLOR;
    float2 uv : UV0;
};

float3 GetPos(VertexInput input, float4x4 objectToWorld, float3 cameraDir, float3 up, float3 size) {

    float3 pos = mul(GetRotationFromLookAtMatrix(cameraDir, up, input.initRotation.w),
        positions[input.vertexId].xyz * size.xyz);
    pos = mul(AxisRadianToMatrix(float4(0, 1, 0, input.rotateVector.w)), pos);
    pos += input.position.xyz;
    pos = mul(objectToWorld, float4(pos, 1.0)).xyz;
    return pos;
}

float3 GetVelocityFacingPos(VertexInput input, float4x4 objectToWorld, float3 cameraDir) {
    if (length(input.velocity) == 0.f) {
        return GetPos(input, objectToWorld, cameraDir, input.up.xyz, input.scale.xyz);
    }
    float3x3 rotation = GetRotationFromLookAtMatrix(cameraDir, input.velocity.xyz);
    float3 pos = (input.scale.x < input.scale.z) ? mul(rotation, positions[input.vertexId].xyz * input.scale.xyz)
        : mul(rotation, positions[input.vertexId].xyz * float3(input.scale.z, input.scale.y, input.scale.x));
    pos += input.position.xyz;
    pos = mul(objectToWorld, float4(pos, 1.0)).xyz;
    return pos;
}

float3 GetCustomFacingPos(VertexInput input, float4x4 objectToWorld) {
    float3 pos = mul(QuaternionToMatrix(QuatNormalize(float4(1, 0, 0, 0))),
        positions[input.vertexId].xyz * input.scale.xyz); // rotate 180 around the x-axis
    pos = mul(AxisRadianToMatrix(input.initRotation), pos);
    pos = mul(AxisRadianToMatrix(input.rotateVector), pos);
    pos += input.position.xyz;
    pos = mul(objectToWorld, float4(pos, 1.0)).xyz;
    return pos;
}

VertexOutput MainVS(in VertexInput input, uint instanceId : SV_InstanceID)
{
    VertexOutput output;
    VsSystemValues SV;
    SV.m_instanceId = instanceId;
    float4x4 objectToWorld = GetObjectToWorldMatrix(SV);
    float3 worldOffset = float3(objectToWorld[0][3], objectToWorld[1][3], objectToWorld[2][3]);

    float3 cameraDir;
    float3 pos;

    switch (o_facingMode)
    {
    case FacingMode::CameraPos:
        cameraDir = normalize(ViewSrg::m_worldPosition - worldOffset - input.position.xyz);
        pos = GetPos(input, objectToWorld, cameraDir, float3(0, 0, 1), input.scale.xyz);
        break;
    case FacingMode::CameraSquare:
        cameraDir = -mul(ViewSrg::m_viewMatrixInverse, float4(0, 0, -1, 0)).xyz;
        pos = GetPos(input, objectToWorld, cameraDir, input.up.xyz, float3(input.scale.x, input.scale.y, input.scale.x));
        break;
    case FacingMode::CameraRectangle:
        cameraDir = -mul(ViewSrg::m_viewMatrixInverse, float4(0, 0, -1, 0)).xyz;
        pos = GetPos(input, objectToWorld, cameraDir, input.up.xyz, input.scale.xyz);
        break;
    case FacingMode::Velocity:
        cameraDir = normalize(ViewSrg::m_worldPosition - worldOffset - input.position.xyz);
        pos = GetVelocityFacingPos(input, objectToWorld, cameraDir);
        break;
    case FacingMode::Custom:
        pos = GetCustomFacingPos(input, objectToWorld);
        break;
    }

    output.position = mul(ViewSrg::m_viewProjectionMatrix, float4(pos, 1.0));
    output.uv = uvs[input.vertexId] / input.subuv.xy + input.subuv.zw;
    output.color = input.color;
    return output;
}

struct PixelOutput
{
     float4 color : SV_Target0;
};

PixelOutput MainPS(in VertexOutput input)
{
    PixelOutput output;
    output.color = input.color * MaterialSrg::m_baseColorMap.Sample(MaterialSrg::m_sampler, input.uv);
    float2 emissiveUv = uvs[MaterialSrg::m_emissiveMapUvIndex];
    float3 emissiveValue = GetEmissiveInput(MaterialSrg::m_emissiveMap, MaterialSrg::m_sampler, input.uv,
        MaterialSrg::m_emissiveIntensity, MaterialSrg::m_emissiveColor.rgb, o_emissiveEnabled, o_emissive_useTexture);
    output.color.rgb += emissiveValue;
    CheckClipping(output.color.a, MaterialSrg::m_alphaCutoff);
    return output;
}
